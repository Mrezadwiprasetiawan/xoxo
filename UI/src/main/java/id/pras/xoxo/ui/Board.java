package id.pras.xoxo.ui;

import android.content.Context;
import android.graphics.Canvas;
import android.view.View;

/**
 * Abstract class representing a Tic-Tac-Toe board for the XOXO game. It handles the rendering of
 * the board, cells, and player moves (X, O). The class also supports setting the current player,
 * board state, and handling the drawing of the board.
 *
 * <p>Classes that extend this class must implement methods to draw the board background, lines, and
 * player symbols (X, O).
 *
 * <p>This class implements the {@link BoardInterface} which defines the core methods for
 * interacting with the board.
 *
 * @see BoardInterface
 * @see SimpleBoard
 * 
 * <p>javadoc comment generated by ChatGpt but verified by me XD
 * @author [M Reza Dwi Prasetiawan]
 * @version 1.0
 */
public abstract class Board extends View implements BoardInterface {

  /** Constant representing an empty cell */
  public static final byte NULL = 0;

  /** Constant representing player O */
  public static final byte O = 1;

  /** Constant representing player X */
  public static final byte X = -1;

  private final int PADDING_PX = 50; // Default board padding in pixels
  private final byte[][] board;
  private volatile byte player;
  private final int sideSize;
  private int cellSize;
  private float offsetX;
  private float offsetY;
  private final int winSize;
  private volatile boolean winState = false;
  private Canvas canvas;

  /**
   * Constructs a new Board with the given side size and win size.
   *
   * @param context the context in which the view is running
   * @param sideSize the size of one side of the board (must be greater than 0)
   * @param winSize the number of consecutive marks needed to win (must be less than or equal to
   *     sideSize)
   * @throws BoardException if sideSize is zero or winSize is greater than sideSize
   */
  public Board(Context context, int sideSize, int winSize) {
    this(context, sideSize, winSize, O);
  }

  /**
   * Constructs a new Board with the given side size, win size, and first player.
   *
   * @param context the context in which the view is running
   * @param sideSize the size of one side of the board (must be greater than 0)
   * @param winSize the number of consecutive marks needed to win (must be less than or equal to
   *     sideSize)
   * @param firstPlayer the player to start the game (must be O or X)
   * @throws BoardException if sideSize is zero, winSize is greater than sideSize, or firstPlayer is
   *     NULL
   */
  public Board(Context context, int sideSize, int winSize, byte firstPlayer) {
    super(context);
    if (sideSize == 0) throw new BoardException(BoardException.ZERO_SIDE_SIZE_MSG);
    if (winSize > sideSize) throw new BoardException(BoardException.WIN_SIZE_EXCEPTION_MSG);
    if (player == NULL) throw new BoardException(BoardException.ZERO_ROLE_EXCEPTION);
    this.sideSize = sideSize;
    this.board = new byte[sideSize][sideSize];
    this.winSize = winSize;
    setCurrentPlayer(firstPlayer);
  }

  /**
   * Called to draw the board and update the canvas.
   *
   * @param canvas the canvas on which the background and grid will be drawn
   */
  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    this.canvas = canvas;
    calcOffsetAndCellSize();
    drawBoard();
  }

  /** Calculates the offset and size of each cell based on the dimensions of the board. */
  protected void calcOffsetAndCellSize() {
    int widthPx = getWidth();
    int heightPx = getHeight();
    cellSize = Math.min(widthPx - PADDING_PX, heightPx - PADDING_PX) / sideSize;
    offsetX = (widthPx - (cellSize * sideSize)) / 2;
    offsetY = (heightPx - (cellSize * sideSize)) / 2;
  }

  /** Draws the grid and player symbols (X, O) on the board. */
  private void drawBoard() {
    drawBackground(canvas);
    for (int i = 0; i <= sideSize; i++) {
      float posX = offsetX + i * cellSize;
      float posY = offsetY + i * cellSize;
      drawBoardLine(canvas, posX, offsetY, posX, offsetY + sideSize * cellSize);
      drawBoardLine(canvas, offsetX, posY, offsetX + sideSize * cellSize, posY);
    }
    for (int x = 0; x < sideSize; x++) {
      for (int y = 0; y < sideSize; y++) {
        if (board[x][y] != NULL) {
          if (board[x][y] == X) {
            drawX(x, y);
          } else if (board[x][y] == O) {
            drawO(x, y);
          }
        }
      }
    }
  }

  /**
   * Draws the background of the board. Classes that extend this class must implement this method.
   *
   * @param canvas the canvas on which the background is drawn
   */
  protected abstract void drawBackground(Canvas canvas);

  /**
   * Draws an O symbol at the specified position. Must only be called after onDraw is invoked.
   *
   * @param x the x-coordinate on the board
   * @param y the y-coordinate on the board
   */
  public void drawO(int x, int y) {
    if (canvas == null)
      throw new RuntimeException("Can't draw O/X before Canvas is initialized in onDraw event");
    drawO(canvas, x, y);
  }

  /**
   * Draws an X symbol at the specified position. Must only be called after onDraw is invoked.
   *
   * @param x the x-coordinate on the board
   * @param y the y-coordinate on the board
   */
  @Override
  public void drawX(int x, int y) {
    if (canvas == null)
      throw new RuntimeException("Can't draw O/X before Canvas is initialized in onDraw event");
    drawX(canvas, x, y);
  }

  /**
   * Draws an O symbol on the canvas at the specified board coordinates. Classes that extend this
   * class must implement this method.
   *
   * @param canvas the canvas on which the O symbol is drawn
   * @param x the x-coordinate on the board
   * @param y the y-coordinate on the board
   */
  protected abstract void drawO(Canvas canvas, int x, int y);

  /**
   * Draws an X symbol on the canvas at the specified board coordinates. Classes that extend this
   * class must implement this method.
   *
   * @param canvas the canvas on which the X symbol is drawn
   * @param x the x-coordinate on the board
   * @param y the y-coordinate on the board
   */
  protected abstract void drawX(Canvas canvas, int x, int y);

  /**
   * Draws a custom line on the board between two points. Classes that extend this class must
   * implement this method.
   *
   * @param canvas the canvas on which the line is drawn
   * @param x0 the starting x-coordinate of the line
   * @param y0 the starting y-coordinate of the line
   * @param x1 the ending x-coordinate of the line
   * @param y1 the ending y-coordinate of the line
   */
  protected abstract void drawBoardLine(Canvas canvas, float x0, float y0, float x1, float y1);

  /**
   * Sets the value of a cell at the specified board coordinates with the given player's mark.
   *
   * @param x the x-coordinate on the board
   * @param y the y-coordinate on the board
   * @param role the player's mark (O or X)
   * @return true if the value was successfully set, false if the cell is already occupied
   */
  protected boolean setValue(int x, int y, byte role) {
    if (x < 0 || y < 0 || x >= sideSize || y >= sideSize) return false;
    if (board[x][y] == NULL) {
      board[x][y] = role;
      invalidate(); // Redraw the board
      return true;
    }
    return false;
  }

  /**
   * Sets the value of a cell at the specified board coordinates with the current player's mark.
   *
   * @param x the x-coordinate on the board
   * @param y the y-coordinate on the board
   * @return true if the value was successfully set, false if the cell is already occupied
   */
  protected boolean setValue(int x, int y) {
    return setValue(x, y, player);
  }

  /**
   * Returns the current state of the board as a 2D byte array.
   *
   * @return the current board
   */
  @Override
  public byte[][] getBoard() {
    return this.board;
  }

  /**
   * Returns the size required to win the game.
   *
   * @return the number of consecutive marks needed to win
   */
  @Override
  public int getWinSize() {
    return this.winSize;
  }

  /**
   * Sets the win state of the game. This method can only be called by classes that extend this
   * class.
   *
   * @param winState true if there is a winner, false otherwise
   */
  protected void setWinState(boolean winState) {
    this.winState = winState;
  }

  /**
   * Returns the win state of the game.
   *
   * @return true if there is a winner, false otherwise
   */
  @Override
  public boolean getWinState() {
    return this.winState;
  }

  /**
   * Returns the size of each cell on the board in pixels.
   *
   * @return the cell size in pixels
   */
  public int getCellSize() {
    return this.cellSize;
  }

  /**
   * Returns the horizontal offset of the board within the view.
   *
   * @return the horizontal offset in pixels
   */
  public float getOffsetX() {
    return this.offsetX;
  }

  /**
   * Returns the vertical offset of the board within the view.
   *
   * @return the vertical offset in pixels
   */
  public float getOffsetY() {
    return this.offsetY;
  }

  /**
   * Sets the current player. This method can only be called by classes that extend this class.
   *
   * @param player the player to set (O or X)
   */
  protected void setCurrentPlayer(byte player) {
    this.player = player;
  }

  /**
   * Returns the current player (O or X).
   *
   * @return the current player
   */
  @Override
  public byte getCurrentPlayer() {
    return player;
  }

  /** Custom exception class for the Board, thrown in case of invalid board configurations. */
  public class BoardException extends RuntimeException {

    public static final String ZERO_ROLE_EXCEPTION = "Role can't be 0";
    public static final String NOT_SQUARE_MSG = "Board not square";
    public static final String WIN_SIZE_EXCEPTION_MSG = "Win size greater than board size!";
    public static final String ZERO_SIDE_SIZE_MSG = "You can't create a board with zero side size!";

    /**
     * Constructs a new BoardException with the specified error message.
     *
     * @param msg the error message
     */
    private BoardException(String msg) {
      super(msg);
    }
  }
}
